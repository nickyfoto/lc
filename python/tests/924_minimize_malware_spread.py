#
# @lc app=leetcode id=924 lang=python3
#
# [924] Minimize Malware Spread
#
# https://leetcode.com/problems/minimize-malware-spread/description/
#
# algorithms
# Hard (41.45%)
# Likes:    215
# Dislikes: 177
# Total Accepted:    18.8K
# Total Submissions: 45.3K
# Testcase Example:  '[[1,1,0],[1,1,0],[0,0,1]]\n[0,1]'
#
# In a network of nodes, each node i is directly connected to another node j if
# and only if graph[i][j] = 1.
# 
# Some nodes initial are initially infected by malware.  Whenever two nodes are
# directly connected and at least one of those two nodes is infected by
# malware, both nodes will be infected by malware.  This spread of malware will
# continue until no more nodes can be infected in this manner.
# 
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network, after the spread of malware stops.
# 
# We will remove one node from the initial list.  Return the node that if
# removed, would minimize M(initial).  If multiple nodes could be removed to
# minimize M(initial), return such a node with the smallest index.
# 
# Note that if a node was removed from the initial list of infected nodes, it
# may still be infected later as a result of the malware spread.
# 
# 
# 
# 
# 
# 
# Example 1:
# 
# 
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# 
# 
# Example 2:
# 
# 
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# 
# 
# Example 3:
# 
# 
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
# 
# 
# 
# 
# Note:
# 
# 
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length
# 
# 
#

# @lc code=start
class UF:
    def __init__(self, total):
        self.arr = list(range(total))
    def find(self, p):
        while p != self.arr[p]:
            p = self.arr[p]
        return p
    def union(self, p, q):
        rp = self.find(p)
        rq = self.find(q)
        if rp == rq:
            return
        self.arr[rq] = rp
class Solution:
    # def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    def minMalwareSpread(self, graph, initial):
        """
        cn is number of node that i have a path to
        """
        n = len(graph)
        uf = UF(n)
        for r in range(n):
            for c in range(r+1, n):
                if graph[r][c] == 1:
                    uf.union(r,c)
        cn = []
        for i in initial:
            ctn = 0
            for j in range(n):
                if i != j and (graph[i][j] == 1 or uf.find(i) == uf.find(j)):
                    ctn += 1
            cn.append(ctn)
        # print(cn)
        indices = list(range(len(initial)))
        indices.sort(key=lambda i: [-cn[i], initial[i]])
        # print(indices)
        return initial[indices[0]]
# @lc code=end
